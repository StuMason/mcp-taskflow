This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  lib/
    supabase-client.ts
    types.ts
supabase/
  migrations/
    20240314_initial_schema.sql
  .gitignore
.gitignore
.repomixignore
index.ts
package.json
readme.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/lib/supabase-client.ts">
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './types.js';

// Local Supabase connection details (from npx supabase status)
const supabaseUrl = 'http://127.0.0.1:54321';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImV4cCI6MTk4MzgxMjk5Nn0.EGIM96RAZx35lJzdJsyH-qQwv8Hdp7fsn3W0YpN81IU';

// Create a single supabase client for interacting with your database
const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  },
  global: {
    headers: {
      'Content-Type': 'application/json'
    }
  }
});

// Test the connection silently
const testConnection = async (): Promise<void> => {
  try {
    await supabase.from('sessions').select('count').limit(0);
  } catch (error) {
    // Only log errors, not success
    console.error('Supabase connection error:', error instanceof Error ? error.message : 'Unknown error');
  }
};

// Run the connection test
testConnection();

export default supabase;
</file>

<file path="src/lib/types.ts">
export interface Session {
  id: string;
  task_type: string;
  context_description: string;
  start_time: string;
  end_time: string | null;
}

export interface FileChange {
  id: string;
  session_id: string;
  file_path: string;
  change_type: 'created' | 'modified' | 'deleted';
  timestamp: string;
}

export interface Checkpoint {
  id: string;
  session_id: string;
  progress: string;
  changes_description: string;
  current_thinking: string;
  next_steps: string;
  timestamp: string;
}

export interface Database {
  public: {
    Tables: {
      sessions: {
        Row: Session;
        Insert: Omit<Session, 'id'>;
        Update: Partial<Omit<Session, 'id'>>;
      };
      file_changes: {
        Row: FileChange;
        Insert: Omit<FileChange, 'id'>;
        Update: Partial<Omit<FileChange, 'id'>>;
      };
      checkpoints: {
        Row: Checkpoint;
        Insert: Omit<Checkpoint, 'id'>;
        Update: Partial<Omit<Checkpoint, 'id'>>;
      };
    };
  };
}
</file>

<file path="supabase/migrations/20240314_initial_schema.sql">
-- Create tables for MCP Taskflow

-- Sessions table
CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  task_type TEXT NOT NULL,
  context_description TEXT,
  start_time TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  end_time TIMESTAMP WITH TIME ZONE
);

-- File changes table
CREATE TABLE file_changes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id TEXT REFERENCES sessions(id),
  file_path TEXT NOT NULL,
  change_type TEXT NOT NULL CHECK (change_type IN ('created', 'modified', 'deleted')),
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- Checkpoints table
CREATE TABLE checkpoints (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id TEXT REFERENCES sessions(id),
  progress TEXT NOT NULL,
  changes_description TEXT NOT NULL,
  current_thinking TEXT NOT NULL,
  next_steps TEXT,
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX idx_file_changes_session_id ON file_changes(session_id);
CREATE INDEX idx_file_changes_file_path ON file_changes(file_path);
CREATE INDEX idx_checkpoints_session_id ON checkpoints(session_id);

-- Add comments for documentation
COMMENT ON TABLE sessions IS 'Tracks assistant sessions';
COMMENT ON TABLE file_changes IS 'Records modifications to files';
COMMENT ON TABLE checkpoints IS 'Captures progress at specific points in time';
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path=".gitignore">
# Dependencies
node_modules/
package-lock.json
yarn.lock

# Build outputs
dist/
build/
*.js.map

# TypeScript
*.tsbuildinfo

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.*.local

# IDE/Editor specific
.vscode/
.idea/
*.swp
*.swo
.DS_Store

# Test coverage
coverage/
</file>

<file path=".repomixignore">
supabase/config.toml
</file>

<file path="index.ts">
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import type { ZodRawShape } from "zod";
import supabase from "./src/lib/supabase-client.js";

// Define message types
interface SystemMessage {
  type: 'system_message';
  content: Array<{
    type: string;
    text: string;
  }>;
}

// Define types for tool parameters
interface InitializeAssistantParams {
  taskType: "code-editing" | "planning" | "research" | "exploration";
  contextDescription?: string;
}

interface RecordFileChangeParams {
  sessionId?: string;
  filePath: string;
  changeType: "created" | "modified" | "deleted";
}

interface CreateProgressCheckpointParams {
  sessionId?: string;
  progress: string;
  changesDescription: string;
  currentThinking: string;
  nextSteps?: string;
}

// Create the MCP server with proper message handling
const server = new McpServer({
  name: "Taskflow",
  version: "1.0.0",
  // Add custom message handler
  async onMessage(message: SystemMessage | unknown) {
    // Handle system messages
    if (typeof message === 'object' && message !== null && 'type' in message && message.type === 'system_message') {
      return {
        jsonrpc: "2.0",
        result: {
          type: "success",
          content: (message as SystemMessage).content
        }
      };
    }
    return null; // Let default handler process other messages
  }
});

// Integration with your MCP server tools
server.tool(
  "initialize-assistant",
  "Initialize the assistant for a specific task type. MUST be called at the start of every conversation.",
  {
    taskType: z
      .enum(["code-editing", "planning", "research", "exploration"])
      .describe(
        "The type of task you (the assistant) are performing in this conversation - YOU MUST initialize before any other actions"
      ),
    contextDescription: z
      .string()
      .optional()
      .describe(
        "Brief description of what you (the assistant) will be helping with - provide context for better tracking"
      ),
  } as ZodRawShape,
  async (args) => {
    const { taskType, contextDescription } = args;
    const sessionId =
      Date.now().toString(36) + Math.random().toString(36).substring(2);

    // Create new session in Supabase
    const { error } = await supabase
      .from('sessions')
      .insert({
        id: sessionId,
        task_type: taskType,
        context_description: contextDescription || '',
        start_time: new Date().toISOString()
      });

    if (error) {
      console.error(`Error creating session: ${error.message}`);
    }

    return {
      sessionId,
      content: [
        {
          type: "text",
          text: `✅ YOU are now initialized for ${taskType} with session ID: ${sessionId}. REMEMBER: YOU MUST call record-file-change after ANY file operations and create-progress-checkpoint every 3-5 minutes. YOUR SESSION WILL BE INCOMPLETE without these calls.`,
        },
      ],
    };
  }
);

server.tool(
  "record-file-change",
  "Record a file system change. MUST be called after every file operation (create/modify/delete).",
  {
    sessionId: z.string().optional().describe("Your current session ID - YOU MUST include this to maintain continuity"),
    filePath: z.string().describe("Path of the file YOU just created, modified or deleted - REQUIRED after ANY file operation"),
    changeType: z
      .enum(["created", "modified", "deleted"])
      .describe("Type of change YOU just performed - MUST be recorded for system integrity"),
  } as ZodRawShape,
  async (args) => {
    const { sessionId, filePath, changeType } = args;
    // Record the change in Supabase
    const { error } = await supabase
      .from('file_changes')
      .insert({
        session_id: sessionId || '',
        file_path: filePath,
        change_type: changeType,
        timestamp: new Date().toISOString()
      });

    if (error) {
      console.error(`Error recording file change: ${error.message}`);
    }

    return {
      content: [
        {
          type: "text",
          text: `✅ YOU have recorded file change: "${filePath}" (${changeType}). REMEMBER: YOU MUST create a progress checkpoint soon to document your work. Use create-progress-checkpoint to maintain system integrity.`,
        },
      ],
    };
  }
);

server.tool(
  "create-progress-checkpoint",
  "Create a checkpoint to document progress. MUST be called every 3-5 minutes or after significant progress.",
  {
    sessionId: z.string().optional().describe("Your current session ID - include this to maintain continuity"),
    progress: z.string().describe("YOUR description of progress made so far - BE SPECIFIC about what YOU have accomplished"),
    changesDescription: z.string().describe("YOUR summary of changes YOU have made - DETAIL the files modified and how"),
    currentThinking: z.string().describe("YOUR current reasoning and plan - EXPLAIN your thought process clearly"),
    nextSteps: z.string().optional().describe("YOUR planned next actions - OUTLINE what you intend to do next"),
  } as ZodRawShape,
  async (args) => {
    const { sessionId, progress, changesDescription, currentThinking, nextSteps } = args;
    // Create checkpoint record in Supabase
    const timestamp = new Date().toISOString();
    
    const { error } = await supabase
      .from('checkpoints')
      .insert({
        session_id: sessionId || '',
        progress,
        changes_description: changesDescription,
        current_thinking: currentThinking,
        next_steps: nextSteps || '',
        timestamp
      });

    if (error) {
      console.error(`Error creating checkpoint: ${error.message}`);
    }
    
    return {
      content: [
        {
          type: "text",
          text: `✅ YOU have created a checkpoint at ${new Date(timestamp).toLocaleTimeString()}. REMEMBER: YOU MUST continue to call record-file-change after ANY file operations. Your next checkpoint should be created within 3-5 minutes or after significant progress.`,
        },
      ],
    };
  }
);

// Set up STDIO transport and connect
const transport = new StdioServerTransport();

server
  .connect(transport)
  .then(() => {
    console.error("TaskFlow MCP Server running on stdio");
  })
  .catch((error) => {
    console.error(`Error starting server: ${error instanceof Error ? error.message : 'Unknown error'}`);
    process.exit(1);
  });
</file>

<file path="package.json">
{
  "name": "mcp-taskflow",
  "version": "1.0.0",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "start": "NODE_OPTIONS='--loader ts-node/esm' node index.ts",
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.7.0",
    "@supabase/supabase-js": "^2.39.3",
    "cors": "^2.8.5",
    "express": "^5.0.1",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/node": "^20.11.19",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="readme.md">
# TaskFlow

> *Bringing structure and control to AI-assisted coding workflows*

## The Problem

Current AI assistant coding workflows are chaotic. While tools like Cursor, Windsurf, and other Model Context Protocol (MCP) clients unlock powerful AI pair programming capabilities, they frequently suffer from critical issues:

- 🧠 **Context amnesia** - Models forget what they were working on
- 🔄 **Unfocused changes** - Files modified with no clear task boundaries
- 🌊 **Workflow turbulence** - No checkpointing or progress tracking
- 🚧 **Lack of transparency** - Difficult to audit what changed and why

## What is TaskFlow?

TaskFlow is an innovative MCP server that brings structured task management to AI-assisted coding. It creates a framework for more controlled, transparent, and effective AI collaboration through **enforced checkpointing** and **session tracking**.

Unlike traditional approaches that try to limit AI capabilities, TaskFlow enhances them by adding crucial process guardrails:

```
      ┌───────────────┐      ┌───────────────┐
User ─┤ MCP Client    │──────┤ TaskFlow      │
      │ (e.g. Cursor) │      │ Server        │
      └───────────────┘      └───────────────┘
                                    │
                                    ▼
                             ┌───────────────┐
                             │ Session &     │
                             │ Change        │
                             │ Tracking      │
                             └───────────────┘
```

## Key Features

### ✅ Session Initialization

Every conversation begins with a structured initialization, capturing:

- Task type (code-editing, planning, research, etc.)
- Context description
- Session tracking ID

### 📝 File Change Tracking

Every file operation must be explicitly recorded:

- Created, modified, or deleted files
- Automatic association with sessions
- Historical file change tracking

### 🔄 Progress Checkpoints

Regular progress documentation is enforced:

- Current progress summary
- Change descriptions
- Reasoning and thought process
- Planned next steps

### 📊 Data Persistence

All data is stored in a lightweight JSON structure:

- Session information
- File change history
- Progress checkpoints
- Associations between actions

## Why It Works

TaskFlow takes advantage of a key insight: **AI assistants will follow clear, consistent instructions in tool responses**. Rather than trying to "control" the AI through prompting alone, TaskFlow adds structural constraints by:

1. **Requiring initialization** - Creating a clear session start
2. **Enforcing documentation** - Mandatory tracking of file changes
3. **Demanding checkpoints** - Regular progress summaries
4. **Persistent reminders** - Each tool response reinforces proper workflow

## Getting Started

### Prerequisites

- Node.js v16+
- An MCP client like Cursor or any other Model Context Protocol compatible editor

### Installation

```bash
# Clone the repository
git clone https://github.com/stumason/taskflow.git

# Install dependencies
cd taskflow
npm install

# Start the server
npm start
```

### Connecting to an MCP client

TaskFlow uses the standard MCP STDIO interface. In Cursor, you can configure it by:

1. Open Settings
2. Navigate to AI > Advanced
3. Set "Model Context Protocol Server" to the path of your TaskFlow server.js
4. Restart Cursor

## Roadmap

TaskFlow is under active development. Future enhancements include:

- [ ] **Session Review Tool** - Generate summaries of completed sessions
- [ ] **User Feedback Integration** - Allow explicit approval/rejection of changes
- [ ] **Web Dashboard** - Visual reporting of sessions and changes
- [ ] **Git Integration** - Associate sessions with commits
- [ ] **Multi-Agent Support** - Coordinated workflows across multiple AI agents
- [ ] **Task Templates** - Pre-defined structured workflows for common tasks

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the ISC License - see the LICENSE file for details.

---

TaskFlow was created to make AI-assisted coding more predictable, transparent, and effective. By adding structure to the chaotic world of "vibe coding," it aims to enhance rather than restrict the powerful capabilities of modern AI coding assistants.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": ".",
    "declaration": true,
    "allowJs": true,
    "resolveJsonModule": true
  },
  "ts-node": {
    "esm": true,
    "experimentalSpecifierResolution": "node"
  },
  "include": ["./**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
</file>

</files>
