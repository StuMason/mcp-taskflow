This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
lib/
  supabase-client.ts
  types.ts
tools/
  application/
    create-application.ts
    create-feature.ts
    create-task.ts
    get-applications.ts
    get-features.ts
    get-session-history.ts
    get-tasks.ts
    index.ts
    update-feature-status.ts
    update-task-status.ts
  session/
    end-session.ts
    index.ts
    initialize.ts
  tracking/
    create-progress-checkpoint.ts
    create-snapshot.ts
    index.ts
    log-decision.ts
    record-file-change.ts
  index.ts
utils/
  responses.ts
  validation.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="lib/supabase-client.ts">
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Hard-coded credentials for development
const supabaseUrl = 'http://localhost:54321';  
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0';

console.log('Using development Supabase credentials');

// Create a single supabase client for interacting with your database
const supabase = createClient<Database>(supabaseUrl, supabaseKey);

export default supabase;
</file>

<file path="lib/types.ts">
// Application represents a top-level software product
export interface Application {
  id: string;
  name: string;
  description: string | null;
  repository_url: string | null;
  created_at: string;
  updated_at: string;
}

// Feature represents a major functionality group within an application
export interface Feature {
  id: string;
  application_id: string;
  name: string;
  description: string | null;
  status: 'planned' | 'in_progress' | 'completed' | 'abandoned';
  priority: number;
  created_at: string;
  updated_at: string;
}

// Task represents a specific work item within a feature
export interface Task {
  id: string;
  feature_id: string;
  name: string;
  description: string | null;
  acceptance_criteria: string | null;
  status: 'backlog' | 'ready' | 'in_progress' | 'review' | 'completed';
  priority: number;
  created_at: string;
  updated_at: string;
}

// Session represents an AI assistant working session
export interface Session {
  id: string;
  task_id: string | null;
  application_id: string | null;
  feature_id: string | null;
  task_type: string;
  context_description: string | null;
  status: 'active' | 'completed' | 'abandoned';
  start_time: string;
  end_time: string | null;
}

// FileChange represents a modification to a file during a session
export interface FileChange {
  id: string;
  session_id: string;
  file_path: string;
  change_type: 'created' | 'modified' | 'deleted';
  timestamp: string;
}

// Checkpoint represents a progress marker during a session
export interface Checkpoint {
  id: string;
  session_id: string;
  progress: string;
  changes_description: string;
  current_thinking: string;
  next_steps: string | null;
  timestamp: string;
}

// Snapshot captures the actual content of a file at a point in time
export interface Snapshot {
  id: string;
  session_id: string;
  file_path: string;
  content: string;
  timestamp: string;
}

// Decision records a key decision made during development
export interface Decision {
  id: string;
  session_id: string;
  description: string;
  reasoning: string;
  alternatives: string | null;
  timestamp: string;
}

// Complete Database type for Supabase
export interface Database {
  public: {
    Tables: {
      applications: {
        Row: Application;
        Insert: Omit<Application, 'id' | 'created_at' | 'updated_at'>;
        Update: Partial<Omit<Application, 'id' | 'created_at' | 'updated_at'>>;
      };
      features: {
        Row: Feature;
        Insert: Omit<Feature, 'id' | 'created_at' | 'updated_at'>;
        Update: Partial<Omit<Feature, 'id' | 'created_at' | 'updated_at'>>;
      };
      tasks: {
        Row: Task;
        Insert: Omit<Task, 'id' | 'created_at' | 'updated_at'>;
        Update: Partial<Omit<Task, 'id' | 'created_at' | 'updated_at'>>;
      };
      sessions: {
        Row: Session;
        Insert: Omit<Session, 'id'>;
        Update: Partial<Omit<Session, 'id'>>;
      };
      file_changes: {
        Row: FileChange;
        Insert: Omit<FileChange, 'id'>;
        Update: Partial<Omit<FileChange, 'id'>>;
      };
      checkpoints: {
        Row: Checkpoint;
        Insert: Omit<Checkpoint, 'id'>;
        Update: Partial<Omit<Checkpoint, 'id'>>;
      };
      snapshots: {
        Row: Snapshot;
        Insert: Omit<Snapshot, 'id'>;
        Update: Partial<Omit<Snapshot, 'id'>>;
      };
      decisions: {
        Row: Decision;
        Insert: Omit<Decision, 'id'>;
        Update: Partial<Omit<Decision, 'id'>>;
      };
    };
  };
}
</file>

<file path="tools/application/create-application.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Create a new application in the system.";

// Tool schema
export const schema = z.object({
  name: z.string().describe("Name of the application"),
  description: z.string().optional().describe("Description of the application"),
  repositoryUrl: z.string().optional().describe("URL to the application's repository")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Check if application already exists with this name
    const { data: existingApp, error: checkError } = await supabase
      .from("applications")
      .select("id")
      .eq("name", params.name)
      .maybeSingle();

    if (checkError) {
      return createResponse(false, 
        "Application Creation Failed", 
        `Error checking application existence: ${checkError.message}`
      );
    }

    if (existingApp) {
      return createResponse(false, 
        "Application Already Exists", 
        `Application with name '${params.name}' already exists`
      );
    }

    // Create the new application
    const { data, error } = await supabase
      .from("applications")
      .insert([
        {
          name: params.name,
          description: params.description || null,
          repository_url: params.repositoryUrl || null
        }
      ])
      .select()
      .single();

    if (error) {
      return createResponse(false, 
        "Application Creation Failed", 
        `Error creating application: ${error.message}`
      );
    }

    return createResponse(true, 
      "Application Created", 
      `Application '${params.name}' created successfully`,
      { application: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Application Creation Failed", 
      `Failed to create application: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/application/create-feature.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Create a new feature for an application.";

// Tool schema
export const schema = z.object({
  applicationId: z.string().describe("ID of the parent application"),
  name: z.string().describe("Name of the feature"),
  description: z.string().optional().describe("Description of the feature"),
  status: z.enum(["planned", "in_progress", "completed", "abandoned"])
    .default("planned")
    .describe("Current status of the feature"),
  priority: z.number().default(1).describe("Priority of the feature (higher number = higher priority)")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Check if application exists
    const { data: application, error: appError } = await supabase
      .from("applications")
      .select("id")
      .eq("id", params.applicationId)
      .maybeSingle();

    if (appError) {
      return createResponse(false, 
        "Feature Creation Failed", 
        `Error checking application existence: ${appError.message}`
      );
    }

    if (!application) {
      return createResponse(false, 
        "Feature Creation Failed", 
        `Application with ID ${params.applicationId} does not exist`
      );
    }

    // Check if feature already exists with this name for this application
    const { data: existingFeature, error: checkError } = await supabase
      .from("features")
      .select("id")
      .eq("application_id", params.applicationId)
      .eq("name", params.name)
      .maybeSingle();

    if (checkError) {
      return createResponse(false, 
        "Feature Creation Failed", 
        `Error checking feature existence: ${checkError.message}`
      );
    }

    if (existingFeature) {
      return createResponse(false, 
        "Feature Already Exists", 
        `Feature with name '${params.name}' already exists for this application`
      );
    }

    // Create the new feature
    const { data, error } = await supabase
      .from("features")
      .insert([
        {
          application_id: params.applicationId,
          name: params.name,
          description: params.description || null,
          status: params.status,
          priority: params.priority
        }
      ])
      .select()
      .single();

    if (error) {
      return createResponse(false, 
        "Feature Creation Failed", 
        `Error creating feature: ${error.message}`
      );
    }

    return createResponse(true, 
      "Feature Created", 
      `Feature '${params.name}' created successfully`,
      { feature: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Feature Creation Failed", 
      `Failed to create feature: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/application/create-task.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Create a new task for a feature.";

// Tool schema
export const schema = z.object({
  featureId: z.string().describe("ID of the parent feature"),
  name: z.string().describe("Name of the task"),
  description: z.string().optional().describe("Description of the task"),
  acceptanceCriteria: z.string().optional().describe("Acceptance criteria for the task"),
  status: z.enum(["backlog", "ready", "in_progress", "review", "completed"])
    .default("backlog")
    .describe("Current status of the task"),
  priority: z.number().default(1).describe("Priority of the task (higher number = higher priority)")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Check if feature exists
    const { data: featureData, error: featureError } = await supabase
      .from("features")
      .select("id")
      .eq("id", params.featureId)
      .single();

    if (featureError || !featureData) {
      return createResponse(false, 
        "Task Creation Failed", 
        `Feature not found with ID: ${params.featureId}`
      );
    }

    // Check if task already exists with this name for this feature
    const { data: existingTask, error: checkError } = await supabase
      .from("tasks")
      .select("id")
      .eq("feature_id", params.featureId)
      .eq("name", params.name)
      .maybeSingle();

    if (checkError) {
      return createResponse(false, 
        "Task Creation Failed", 
        `Error checking task existence: ${checkError.message}`
      );
    }

    if (existingTask) {
      return createResponse(false, 
        "Task Already Exists", 
        `Task with name '${params.name}' already exists for this feature`
      );
    }

    // Create the new task
    const { data, error } = await supabase
      .from("tasks")
      .insert([
        {
          feature_id: params.featureId,
          name: params.name,
          description: params.description || null,
          acceptance_criteria: params.acceptanceCriteria || null,
          status: params.status,
          priority: params.priority
        }
      ])
      .select()
      .single();

    if (error) {
      return createResponse(false, 
        "Task Creation Failed", 
        `Error creating task: ${error.message}`
      );
    }

    return createResponse(true, 
      "Task Created", 
      `Task '${params.name}' created successfully`,
      { task: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Task Creation Failed", 
      `Failed to create task: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/application/get-applications.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Get a list of applications in the system.";

// Tool schema
export const schema = z.object({
  random_string: z.string().optional().describe("Dummy parameter for no-parameter tools")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Query the applications from the database
    const { data, error } = await supabase
      .from("applications")
      .select("*")
      .order("created_at", { ascending: false });

    if (error) {
      return createResponse(false, 
        "Failed to Retrieve Applications", 
        `Error retrieving applications: ${error.message}`
      );
    }

    return createResponse(true, 
      "Applications Retrieved", 
      `Successfully retrieved ${data.length} applications`,
      { applications: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Failed to Retrieve Applications", 
      `Error retrieving applications: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/application/get-features.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Get features for an application.";

// Tool schema
export const schema = z.object({
  applicationId: z.string().describe("The application ID to get features for")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Validate the application ID exists
    const { data: application, error: appError } = await supabase
      .from("applications")
      .select("id")
      .eq("id", params.applicationId)
      .maybeSingle();

    if (appError) {
      return createResponse(false, 
        "Failed to Retrieve Features", 
        `Error checking application existence: ${appError.message}`
      );
    }

    if (!application) {
      return createResponse(false, 
        "Failed to Retrieve Features", 
        `Application with ID ${params.applicationId} does not exist`
      );
    }

    // Query the features for the application
    const { data, error } = await supabase
      .from("features")
      .select("*")
      .eq("application_id", params.applicationId)
      .order("created_at", { ascending: false });

    if (error) {
      return createResponse(false, 
        "Failed to Retrieve Features", 
        `Error retrieving features: ${error.message}`
      );
    }

    return createResponse(true, 
      "Features Retrieved", 
      `Successfully retrieved ${data.length} features for application ${params.applicationId}`,
      { features: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Failed to Retrieve Features", 
      `Error retrieving features: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/application/get-session-history.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Get session history for a specific task.";

// Tool schema
export const schema = z.object({
  taskId: z.string().describe("The task ID to retrieve session history for")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Validate the task exists
    const { data: task, error: taskError } = await supabase
      .from("tasks")
      .select("id")
      .eq("id", params.taskId)
      .maybeSingle();

    if (taskError) {
      return createResponse(false, 
        "Failed to Retrieve Session History", 
        `Error checking task existence: ${taskError.message}`
      );
    }

    if (!task) {
      return createResponse(false, 
        "Failed to Retrieve Session History", 
        `Task with ID ${params.taskId} does not exist`
      );
    }

    // Query the sessions for the task
    const { data, error } = await supabase
      .from("sessions")
      .select("*")
      .eq("task_id", params.taskId)
      .order("created_at", { ascending: false });

    if (error) {
      return createResponse(false, 
        "Failed to Retrieve Session History", 
        `Error retrieving session history: ${error.message}`
      );
    }

    // Format the sessions with their associated checkpoints
    const formattedSessions = await Promise.all(data.map(async (session) => {
      const { data: checkpoints, error: checkpointsError } = await supabase
        .from("progress_checkpoints")
        .select("*")
        .eq("session_id", session.id)
        .order("created_at", { ascending: true });

      if (checkpointsError) {
        console.error(`Error fetching checkpoints for session ${session.id}:`, checkpointsError);
      }

      return {
        ...session,
        checkpoints: checkpoints || []
      };
    }));

    return createResponse(true, 
      "Session History Retrieved", 
      `Successfully retrieved ${data.length} sessions for task ${params.taskId}`,
      { sessions: formattedSessions }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Failed to Retrieve Session History", 
      `Error retrieving session history: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/application/get-tasks.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Get tasks for a feature.";

// Tool schema
export const schema = z.object({
  featureId: z.string().describe("The feature ID to get tasks for")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Validate the feature ID exists
    const { data: feature, error: featureError } = await supabase
      .from("features")
      .select("id")
      .eq("id", params.featureId)
      .maybeSingle();

    if (featureError) {
      return createResponse(false, 
        "Failed to Retrieve Tasks", 
        `Error checking feature existence: ${featureError.message}`
      );
    }

    if (!feature) {
      return createResponse(false, 
        "Failed to Retrieve Tasks", 
        `Feature with ID ${params.featureId} does not exist`
      );
    }

    // Query the tasks for the feature
    const { data, error } = await supabase
      .from("tasks")
      .select("*")
      .eq("feature_id", params.featureId)
      .order("created_at", { ascending: false });

    if (error) {
      return createResponse(false, 
        "Failed to Retrieve Tasks", 
        `Error retrieving tasks: ${error.message}`
      );
    }

    return createResponse(true, 
      "Tasks Retrieved", 
      `Successfully retrieved ${data.length} tasks for feature ${params.featureId}`,
      { tasks: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Failed to Retrieve Tasks", 
      `Error retrieving tasks: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/application/index.ts">
import * as getApplications from "./get-applications.js";
import * as getFeatures from "./get-features.js";
import * as getTasks from "./get-tasks.js";
import * as getSessionHistory from "./get-session-history.js";
import * as createApplication from "./create-application.js";
import * as createFeature from "./create-feature.js";
import * as createTask from "./create-task.js";
import * as updateFeatureStatus from "./update-feature-status.js";
import * as updateTaskStatus from "./update-task-status.js";

export const applicationTools = {
  getApplications,
  getFeatures,
  getTasks,
  getSessionHistory,
  createApplication,
  createFeature,
  createTask,
  updateFeatureStatus,
  updateTaskStatus
};
</file>

<file path="tools/application/update-feature-status.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Update the status of a feature.";

// Tool schema
export const schema = z.object({
  featureId: z.string().describe("ID of the feature to update"),
  status: z.enum(["planned", "in_progress", "completed", "abandoned"])
    .describe("New status for the feature")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Check if feature exists
    const { data: feature, error: featureError } = await supabase
      .from("features")
      .select("id, status")
      .eq("id", params.featureId)
      .maybeSingle();

    if (featureError) {
      return createResponse(false, 
        "Feature Status Update Failed", 
        `Error checking feature existence: ${featureError.message}`
      );
    }

    if (!feature) {
      return createResponse(false, 
        "Feature Status Update Failed", 
        `Feature with ID ${params.featureId} does not exist`
      );
    }

    // If status is already set to the requested value, return early
    if (feature.status === params.status) {
      return createResponse(true, 
        "Feature Status Updated", 
        `Feature status is already set to '${params.status}'`
      );
    }

    // Update the feature status
    const { data, error } = await supabase
      .from("features")
      .update({ status: params.status, updated_at: new Date().toISOString() })
      .eq("id", params.featureId)
      .select()
      .single();

    if (error) {
      return createResponse(false, 
        "Feature Status Update Failed", 
        `Error updating feature status: ${error.message}`
      );
    }

    return createResponse(true, 
      "Feature Status Updated", 
      `Successfully updated feature status from '${feature.status}' to '${params.status}'`
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Feature Status Update Failed", 
      `Failed to update feature status: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/application/update-task-status.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "Update the status of a task.";

// Tool schema
export const schema = z.object({
  taskId: z.string().describe("ID of the task to update"),
  status: z.enum(["backlog", "ready", "in_progress", "review", "completed"])
    .describe("New status for the task")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Check if task exists
    const { data: task, error: taskError } = await supabase
      .from("tasks")
      .select("id, status")
      .eq("id", params.taskId)
      .maybeSingle();

    if (taskError) {
      return createResponse(false, 
        "Task Status Update Failed", 
        `Error checking task existence: ${taskError.message}`
      );
    }

    if (!task) {
      return createResponse(false, 
        "Task Status Update Failed", 
        `Task with ID ${params.taskId} does not exist`
      );
    }

    // If status is already set to the requested value, return early
    if (task.status === params.status) {
      return createResponse(true, 
        "Task Status Updated", 
        `Task status is already set to '${params.status}'`
      );
    }

    // Update the task status
    const { data, error } = await supabase
      .from("tasks")
      .update({ status: params.status, updated_at: new Date().toISOString() })
      .eq("id", params.taskId)
      .select()
      .single();

    if (error) {
      return createResponse(false, 
        "Task Status Update Failed", 
        `Error updating task status: ${error.message}`
      );
    }

    return createResponse(true, 
      "Task Status Updated", 
      `Successfully updated task status from '${task.status}' to '${params.status}'`
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Task Status Update Failed", 
      `Failed to update task status: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/session/end-session.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";
import { validateSession } from "../../utils/validation.js";

// Tool description
export const description = "End the current session and mark it as completed.";

// Tool schema
export const schema = z.object({
  sessionId: z.string().describe("Your current session ID to end"),
  summary: z.string().describe("Summary of what was accomplished in this session")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Validate the session exists
    const result = await validateSession(params.sessionId);
    
    if (!result.valid || result.error || !result.data) {
      return createResponse(false, 
        "Session End Failed", 
        result.error || "Invalid or expired session"
      );
    }

    const sessionId = result.data.id;

    // Update the session to mark it as completed
    const { data, error } = await supabase
      .from("sessions")
      .update({ 
        status: "completed",
        end_time: new Date().toISOString(),
        summary: params.summary
      })
      .eq("id", sessionId)
      .select()
      .single();

    if (error) {
      return createResponse(false, 
        "Session End Failed", 
        `Error ending session: ${error.message}`
      );
    }

    return createResponse(true, 
      "Session Ended", 
      "Session ended successfully",
      { session: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Session End Failed", 
      `Failed to end session: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/session/index.ts">
import * as initialize from "./initialize.js";
import * as endSession from "./end-session.js";
// Import other session tools here

export const sessionTools = {
  initialize,
  endSession
  // Add other session tools here
};
</file>

<file path="tools/session/initialize.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "INITIALIZE THE ASSISTANT SESSION - THIS MUST BE CALLED BEFORE ANY OTHER TOOLS";

// Tool schema
export const schema = schemas.session.initialize;

// Tool handler
export async function handler(args: any): Promise<McpResponse> {
  const { taskType, contextDescription, applicationId, featureId, taskId } = args;
  const sessionId = Date.now().toString(36) + Math.random().toString(36).substring(2);

  // Create new session in Supabase with enhanced fields
  const { error } = await supabase
    .from('sessions')
    .insert({
      id: sessionId,
      task_type: taskType,
      context_description: contextDescription || '',
      application_id: applicationId || null,
      feature_id: featureId || null,
      task_id: taskId || null,
      status: 'active',
      start_time: new Date().toISOString(),
      last_checkpoint_at: null,
      last_file_change_at: null,
      last_decision_at: null,
      compliance_score: 100
    });

  if (error) {
    console.error(`Error creating session: ${error.message}`);
    return createResponse(
      false,
      "INITIALIZATION FAILED",
      "The assistant could not be initialized. Ensure your connection is active and try again.",
      undefined,
      ["Database error occurred"],
      ["YOU MUST RETRY INITIALIZATION BEFORE PROCEEDING WITH ANY OTHER ACTIONS"]
    );
  }

  // Prepare context information based on linked entities
  let contextInfo = '';
  let taskName = '';
  let taskDesc = '';
  let featureName = '';
  let appName = '';
  
  if (taskId) {
    const { data: taskData } = await supabase
      .from('tasks')
      .select('name, description, acceptance_criteria, status')
      .eq('id', taskId)
      .single();
      
    if (taskData) {
      taskName = taskData.name;
      taskDesc = taskData.description || '';
      contextInfo += `\n\nTASK ASSIGNMENT: "${taskData.name}" (${taskData.status})
${taskData.description ? `Description: ${taskData.description}` : ''}
${taskData.acceptance_criteria ? `Acceptance Criteria: ${taskData.acceptance_criteria}` : ''}`;
    }
  }
  
  if (featureId) {
    const { data: featureData } = await supabase
      .from('features')
      .select('name, description, status')
      .eq('id', featureId)
      .single();
      
    if (featureData) {
      featureName = featureData.name;
      contextInfo += `\n\nFEATURE CONTEXT: "${featureData.name}" (${featureData.status})
${featureData.description ? `Description: ${featureData.description}` : ''}`;
    }
  }
  
  if (applicationId) {
    const { data: appData } = await supabase
      .from('applications')
      .select('name, description')
      .eq('id', applicationId)
      .single();
      
    if (appData) {
      appName = appData.name;
      contextInfo += `\n\nAPPLICATION CONTEXT: "${appData.name}"
${appData.description ? `Description: ${appData.description}` : ''}`;
    }
  }

  // Get previous sessions for the same task if applicable
  let previousSessionsInfo = '';
  
  if (taskId) {
    const { data: prevSessions } = await supabase
      .from('sessions')
      .select('id, start_time, end_time')
      .eq('task_id', taskId)
      .neq('id', sessionId)
      .order('start_time', { ascending: false })
      .limit(3);
      
    if (prevSessions && prevSessions.length > 0) {
      previousSessionsInfo = `\n\nPREVIOUS WORK SESSIONS:
${prevSessions.map((s: any) => `- Session ${s.id} (${new Date(s.start_time).toLocaleString()})`).join('\n')}`;
    }
  }

  // Check for successful strategies in past sessions
  let successfulStrategies = '';
  
  if (taskType) {
    const { data: strategies } = await supabase
      .from('feedback')
      .select('description, reusability_score')
      .eq('feedback_type', 'positive')
      .gte('reusability_score', 7)
      .contains('applicable_task_types', [taskType])
      .order('reusability_score', { ascending: false })
      .limit(3);
      
    if (strategies && strategies.length > 0) {
      successfulStrategies = `\n\nPROVEN STRATEGIES FOR THIS TASK TYPE:
${strategies.map((s: any) => `- ${s.description} (Effectiveness: ${s.reusability_score}/10)`).join('\n')}`;
    }
  }

  // Create a strict scope boundary with clear task focus
  let scopeStatement = 'STRICT SCOPE BOUNDARY';
  
  if (taskName) {
    scopeStatement += `\nYOU ARE RESTRICTED TO WORKING ONLY ON: "${taskName}"`;
    if (taskDesc) {
      scopeStatement += `\nSPECIFIC TASK DETAILS: "${taskDesc}"`;
    }
  } else if (featureName) {
    scopeStatement += `\nYOU ARE RESTRICTED TO WORKING ONLY ON FEATURE: "${featureName}"`;
  } else if (appName) {
    scopeStatement += `\nYOU ARE RESTRICTED TO WORKING ONLY ON APPLICATION: "${appName}"`;
  } else {
    scopeStatement += `\nYOU ARE RESTRICTED TO WORKING ONLY ON: "${contextDescription || taskType + ' task'}"`;
  }
  
  scopeStatement += '\nDO NOT work on unrelated features or applications.';
  scopeStatement += '\nDO NOT create code or files outside the scope of your assigned task.';
  scopeStatement += '\nDO NOT jump ahead to implementation before planning is complete.';

  // Create a protocol reminder with timing requirements
  const protocolReminder = `\n\nCOMPLIANCE REQUIREMENTS:
- YOU MUST call "MUST-RECORD-EVERY-FILE-CHANGE" after EACH file operation
- YOU MUST create a checkpoint within the next 5 minutes
- YOU MUST document EVERY significant decision with "MUST-LOG-ALL-DECISIONS"
- YOU MUST NOT stray from your assigned task scope
- YOU MUST create snapshots when files reach significant milestones`;

  // Add timing information 
  const nextCheckpointTime = new Date();
  nextCheckpointTime.setMinutes(nextCheckpointTime.getMinutes() + 5);
  
  const timingInfo = `\n\nTIMING REQUIREMENTS:
- First checkpoint due by: ${nextCheckpointTime.toLocaleTimeString()}
- Checkpoints required: Every 3-5 minutes
- File changes must be recorded: Immediately after each change`;

  // Modified return statement
  return {
    content: [
      {
        type: "text" as const,
        text: `SESSION INITIALIZED - ID: ${sessionId}\n\nYOU ARE NOW LOCKED INTO ${taskType.toUpperCase()} MODE${contextInfo}${previousSessionsInfo}${successfulStrategies}\n\n${scopeStatement}${protocolReminder}${timingInfo}\n\nCOMPLIANCE METRICS:\nYour file changes: 0\nYour checkpoints: 0\nYour decisions: 0\nCompliance score: 100/100`
      }
    ],
    sessionId
  };
}
</file>

<file path="tools/tracking/create-progress-checkpoint.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";
import { validateSession } from "../../utils/validation.js";

// Tool description
export const description = "Create a checkpoint to document progress. MUST be called every 3-5 minutes or after significant progress.";

// Tool schema
export const schema = z.object({
  sessionId: z.string().optional().describe("Your current session ID - include this to maintain continuity"),
  progress: z.string().describe("YOUR description of progress made so far - BE SPECIFIC about what YOU have accomplished"),
  changesDescription: z.string().describe("YOUR summary of changes YOU have made - DETAIL the files modified and how"),
  currentThinking: z.string().describe("YOUR current reasoning and plan - EXPLAIN your thought process clearly"),
  nextSteps: z.string().optional().describe("YOUR planned next actions - OUTLINE what you intend to do next")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Validate the session if ID is provided
    let sessionId = params.sessionId;
    if (params.sessionId) {
      const result = await validateSession(params.sessionId);
      
      if (!result.valid || result.error || !result.data) {
        return createResponse(false, 
          "Checkpoint Creation Failed", 
          result.error || "Invalid or expired session"
        );
      }
      
      sessionId = result.data.id;
    }

    // Create the checkpoint
    const { data, error } = await supabase
      .from("checkpoints")
      .insert([
        {
          session_id: sessionId,
          progress: params.progress,
          changes_description: params.changesDescription,
          current_thinking: params.currentThinking,
          next_steps: params.nextSteps || null
        }
      ])
      .select()
      .single();

    if (error) {
      return createResponse(false, 
        "Checkpoint Creation Failed", 
        `Error creating checkpoint: ${error.message}`
      );
    }

    return createResponse(true, 
      "Checkpoint Created", 
      "Progress checkpoint created successfully",
      { checkpoint: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Checkpoint Creation Failed", 
      `Failed to create progress checkpoint: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/tracking/create-snapshot.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";
import { validateSession } from "../../utils/validation.js";

// Tool description
export const description = "Create a content snapshot of a file at the current point in time.";

// Tool schema
export const schema = z.object({
  sessionId: z.string().describe("Your current session ID - REQUIRED to link the snapshot"),
  filePath: z.string().describe("Path of the file to snapshot"),
  content: z.string().describe("The current content of the file")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Validate the session exists
    const result = await validateSession(params.sessionId);
    
    if (!result.valid || result.error || !result.data) {
      return createResponse(false, 
        "Snapshot Creation Failed", 
        result.error || "Invalid or expired session"
      );
    }

    const sessionId = result.data.id;

    // Create a hash of the content for lightweight comparison
    const contentHash = Buffer.from(params.content).toString('base64');

    // Check if a snapshot already exists with similar content for this file
    const { data: existingSnapshot, error } = await supabase
      .from("snapshots")
      .select("id, content_hash")
      .eq("session_id", sessionId)
      .eq("file_path", params.filePath)
      .eq("content_hash", contentHash)
      .maybeSingle();

    // If a snapshot with the same hash exists, don't create a duplicate
    if (!error && existingSnapshot) {
      return createResponse(false, 
        "Snapshot Already Exists", 
        `A snapshot with identical content already exists for ${params.filePath}`
      );
    }

    // If an error occurs that's not just "not found", return the error
    if (error && error.code !== "PGRST116") {
      return createResponse(false, 
        "Snapshot Creation Failed", 
        `Error checking for existing snapshots: ${error.message}`
      );
    }

    // Create the snapshot
    const { data, error: createError } = await supabase
      .from("snapshots")
      .insert([
        {
          session_id: sessionId,
          file_path: params.filePath,
          content: params.content,
          content_hash: contentHash
        }
      ])
      .select()
      .single();

    if (createError) {
      return createResponse(false, 
        "Snapshot Creation Failed", 
        `Error creating snapshot: ${createError.message}`
      );
    }

    return createResponse(true, 
      "Snapshot Created", 
      `Snapshot created successfully for file: ${params.filePath}`,
      { snapshot: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Snapshot Creation Failed", 
      `Failed to create snapshot: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/tracking/index.ts">
import * as recordFileChange from "./record-file-change.js";
import * as createProgressCheckpoint from "./create-progress-checkpoint.js";
import * as createSnapshot from "./create-snapshot.js";
import * as logDecision from "./log-decision.js";
// Import other tracking tools here

export const trackingTools = {
  recordFileChange,
  createProgressCheckpoint,
  createSnapshot,
  logDecision
  // Add other tracking tools here
};
</file>

<file path="tools/tracking/log-decision.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { z } from "zod";
import supabase from "../../lib/supabase-client.js";
import { validateSession } from "../../utils/validation.js";

// Tool description
export const description = "Log a key decision made during development.";

// Tool schema
export const schema = z.object({
  sessionId: z.string().describe("Your current session ID - REQUIRED to link the decision"),
  description: z.string().describe("Brief description of the decision made"),
  reasoning: z.string().describe("Detailed reasoning behind the decision"),
  alternatives: z.string().optional().describe("Alternative approaches that were considered")
});

// Tool handler
export const handler = async (params: z.infer<typeof schema>): Promise<McpResponse> => {
  try {
    // Validate the session exists
    const result = await validateSession(params.sessionId);
    
    if (!result.valid || result.error || !result.data) {
      return createResponse(false, 
        "Decision Logging Failed", 
        result.error || "Invalid or expired session"
      );
    }

    const sessionId = result.data.id;
    // Create the decision log
    const { data, error } = await supabase
      .from("decisions")
      .insert([
        {
          session_id: sessionId,
          description: params.description,
          reasoning: params.reasoning,
          alternatives: params.alternatives || null
        }
      ])
      .select()
      .single();

    if (error) {
      return createResponse(false, 
        "Decision Logging Failed", 
        `Error logging decision: ${error.message}`
      );
    }

    return createResponse(true, 
      "Decision Logged", 
      "Decision logged successfully",
      { decision: data }
    );
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return createResponse(false, 
      "Decision Logging Failed", 
      `Failed to log decision: ${errorMessage}`
    );
  }
};
</file>

<file path="tools/tracking/record-file-change.ts">
import { schemas, createResponse, McpResponse } from "../../utils/responses.js";
import { validateSession, checkpointNeeded, verifyScopeCompliance } from "../../utils/validation.js";
import supabase from "../../lib/supabase-client.js";

// Tool description
export const description = "RECORD A FILE SYSTEM CHANGE - YOU MUST CALL THIS AFTER EVERY FILE OPERATION";

// Tool schema
export const schema = schemas.tracking.recordFileChange;

// Tool handler
export async function handler(args: any): Promise<McpResponse> {
  const { sessionId, filePath, changeType } = args;
  
  // Validate session
  const sessionValidation = await validateSession(sessionId);
  if (!sessionValidation.valid) {
    return createResponse(
      false,
      "INVALID SESSION",
      `The session ID provided is invalid or inactive: ${sessionValidation.error}`,
      undefined,
      ["Session validation failed"],
      ["YOU MUST initialize a valid session before recording file changes"]
    );
  }
  
  // Verify scope compliance
  const scopeCheck = await verifyScopeCompliance(sessionId, filePath, changeType);
  if (!scopeCheck.compliant) {
    // Record the scope violation
    await supabase
      .from('scope_validations')
      .insert({
        session_id: sessionId,
        validation_type: 'scope_check',
        result: 'violation',
        details: `File operation outside scope: ${filePath} (${changeType})`,
        timestamp: new Date().toISOString()
      });
      
    // Update compliance score
    await supabase
      .from('sessions')
      .update({
        compliance_score: supabase.rpc('decrement_compliance_score', { session_id: sessionId, amount: 10 })
      })
      .eq('id', sessionId);
      
    return createResponse(
      false,
      "SCOPE VIOLATION DETECTED",
      `The file operation on "${filePath}" appears to be outside your assigned task scope.`,
      undefined,
      ["This operation may not be relevant to your assigned task", "Your compliance score has been reduced"],
      ["YOU MUST justify why this file change is necessary for your specific task", 
       "YOU MUST focus only on files directly related to your assigned task"]
    );
  }
  
  // Record the change in Supabase
  const { error } = await supabase
    .from('file_changes')
    .insert({
      session_id: sessionId,
      file_path: filePath,
      change_type: changeType,
      timestamp: new Date().toISOString()
    });

  if (error) {
    console.error(`Error recording file change: ${error.message}`);
    return createResponse(
      false,
      "FAILED TO RECORD FILE CHANGE",
      `Unable to record the change to "${filePath}". This operation must be logged for accountability.`,
      undefined,
      ["Database error occurred"],
      ["RETRY recording this file change immediately"]
    );
  }
  
  // Update session last_file_change_at timestamp
  await supabase
    .from('sessions')
    .update({
      last_file_change_at: new Date().toISOString()
    })
    .eq('id', sessionId);
  
  // Calculate session stats
  const { data: fileChanges } = await supabase
    .from('file_changes')
    .select('file_path, change_type')
    .eq('session_id', sessionId);
    
  const { data: checkpoints } = await supabase
    .from('checkpoints')
    .select('id')
    .eq('session_id', sessionId);
    
  const { data: decisions } = await supabase
    .from('decisions')
    .select('id')
    .eq('session_id', sessionId);
    
  const { data: snapshots } = await supabase
    .from('snapshots')
    .select('id')
    .eq('session_id', sessionId);
    
  // Group files by path to show a summary
  const fileCounts: Record<string, { created: number, modified: number, deleted: number }> = {};
  
  fileChanges?.forEach(change => {
    if (!fileCounts[change.file_path]) {
      fileCounts[change.file_path] = { created: 0, modified: 0, deleted: 0 };
    }
    fileCounts[change.file_path][change.change_type as 'created' | 'modified' | 'deleted']++;
  });
  
  // Create a files modified summary
  const filesSummary = Object.entries(fileCounts).map(([path, counts]) => 
    `- ${path}: ${counts.created ? counts.created + ' creates, ' : ''}${counts.modified ? counts.modified + ' modifications, ' : ''}${counts.deleted ? counts.deleted + ' deletions' : ''}`
  ).join('\n');
  
  // Check if checkpoint is needed
  const needsCheckpoint = await checkpointNeeded(sessionId);
  
  // Get task context
  const { data: session } = await supabase
    .from('sessions')
    .select('task_id, compliance_score')
    .eq('id', sessionId)
    .single();
    
  // Get task name if available
  let taskName = '';
  if (session?.task_id) {
    const { data: taskData } = await supabase
      .from('tasks')
      .select('name')
      .eq('id', session.task_id)
      .single();
      
    if (taskData) {
      taskName = taskData.name;
    }
  }
  
  // Prepare guidance based on context
  const warnings = [];
  const actions = [];
  
  if (needsCheckpoint) {
    warnings.push("You have not created a checkpoint recently");
    actions.push("YOU MUST create a checkpoint immediately");
  }
  
  if ((decisions?.length || 0) < 1) {
    warnings.push("You have not logged any key decisions yet");
    actions.push("YOU MUST document important decisions using MUST-LOG-ALL-DECISIONS");
  }
  
  if (changeType === 'modified' && (snapshots?.length || 0) < 1) {
    warnings.push("You have modified files but haven't created any snapshots");
    actions.push("Consider creating a snapshot of significant file versions");
  }
  
  // Reminder about staying in scope
  if (taskName) {
    actions.push(`YOU MUST stay within the scope of task "${taskName}"`);
  }
  
  return createResponse(
    true,
    `FILE ${changeType.toUpperCase()} RECORDED`,
    `The ${changeType} operation on "${filePath}" has been successfully logged.`,
    {
      "Files changed": fileChanges?.length || 0,
      "Checkpoints": checkpoints?.length || 0,
      "Decisions": decisions?.length || 0,
      "Snapshots": snapshots?.length || 0,
      "Compliance score": `${session?.compliance_score || 100}/100`
    },
    warnings,
    actions
  );
}
</file>

<file path="tools/index.ts">
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { sessionTools } from "./session/index.js";
import { trackingTools } from "./tracking/index.js";
import { applicationTools } from "./application/index.js";
import { schemas } from "../utils/responses.js";
import { ZodRawShape } from "zod";
// Import other tool categories

// Type for McpResponse from our utils
import { McpResponse } from "../utils/responses.js";

// Type for RequestHandlerExtra from the MCP SDK
type RequestHandlerExtra = {
  baseUrl: string;
  requestId: string;
  timestamp: number;
};

// Helper function to adapt our handlers to the MCP server expected format
function adaptHandler(handler: any) {
  // @ts-ignore - Ignore typescript errors since we know this function will work properly
  return async (args: Record<string, any>, extra: any): Promise<McpResponse> => {
    return await handler(args);
  };
}

export function registerTools(server: McpServer) {
  // Register session tools
  server.tool(
    "initialize-session", 
    sessionTools.initialize.description, 
    schemas.session.initialize, 
    adaptHandler(sessionTools.initialize.handler)
  );
  
  server.tool(
    "end-session",
    sessionTools.endSession.description,
    schemas.session.end, 
    adaptHandler(sessionTools.endSession.handler)
  );
  
  // Register tracking tools
  server.tool(
    "record-file-change",
    trackingTools.recordFileChange.description,
    schemas.tracking.recordFileChange, 
    adaptHandler(trackingTools.recordFileChange.handler)
  );
  
  server.tool(
    "create-progress-checkpoint",
    trackingTools.createProgressCheckpoint.description,
    schemas.tracking.createProgressCheckpoint, 
    adaptHandler(trackingTools.createProgressCheckpoint.handler)
  );
  
  server.tool(
    "create-snapshot",
    trackingTools.createSnapshot.description,
    schemas.tracking.createSnapshot, 
    adaptHandler(trackingTools.createSnapshot.handler)
  );
  
  server.tool(
    "log-decision",
    trackingTools.logDecision.description,
    schemas.tracking.logDecision, 
    adaptHandler(trackingTools.logDecision.handler)
  );
  
  // Register application tools
  server.tool(
    "get-applications",
    applicationTools.getApplications.description,
    schemas.application.getApplications, 
    adaptHandler(applicationTools.getApplications.handler)
  );
  
  server.tool(
    "get-features",
    applicationTools.getFeatures.description,
    schemas.application.getFeatures, 
    adaptHandler(applicationTools.getFeatures.handler)
  );
  
  server.tool(
    "get-tasks",
    applicationTools.getTasks.description,
    schemas.application.getTasks, 
    adaptHandler(applicationTools.getTasks.handler)
  );
  
  server.tool(
    "get-session-history",
    applicationTools.getSessionHistory.description,
    schemas.application.getSessionHistory, 
    adaptHandler(applicationTools.getSessionHistory.handler)
  );
  
  server.tool(
    "create-application",
    applicationTools.createApplication.description,
    schemas.application.createApplication, 
    adaptHandler(applicationTools.createApplication.handler)
  );
  
  server.tool(
    "create-feature",
    applicationTools.createFeature.description,
    schemas.application.createFeature, 
    adaptHandler(applicationTools.createFeature.handler)
  );
  
  server.tool(
    "create-task",
    applicationTools.createTask.description,
    schemas.application.createTask, 
    adaptHandler(applicationTools.createTask.handler)
  );
  
  server.tool(
    "update-feature-status",
    applicationTools.updateFeatureStatus.description,
    schemas.application.updateFeatureStatus, 
    adaptHandler(applicationTools.updateFeatureStatus.handler)
  );
  
  server.tool(
    "update-task-status",
    applicationTools.updateTaskStatus.description,
    schemas.application.updateTaskStatus, 
    adaptHandler(applicationTools.updateTaskStatus.handler)
  );
  
  console.log("All tools registered successfully");
}
</file>

<file path="utils/responses.ts">
import { z } from "zod";
import type { ZodRawShape } from "zod";

// Define the content types that MCP server expects
export type TextContent = {
  type: "text";
  text: string;
};

export type ImageContent = {
  type: "image";
  data: string;
  mimeType: string;
};

export type ResourceContent = {
  type: "resource";
  resource: {
    text: string;
    uri: string;
    mimeType?: string;
  };
};

export type ContentItem = TextContent | ImageContent | ResourceContent;

export type McpResponse = {
  content: ContentItem[];
  [key: string]: any;
};

// Function to create standardized responses
export function createResponse(
  success: boolean,
  title: string,
  details: string,
  stats?: Record<string, any>,
  warnings: string[] = [],
  actions: string[] = []
): McpResponse {
  const emoji = success ? "✅" : "❌";
  
  // Format warnings with emoji
  const warningSection = warnings.length > 0 
    ? `\n\n⚠️ WARNINGS:\n${warnings.map(w => `- ${w}`).join('\n')}` 
    : '';
  
  // Format required actions with emoji
  const actionSection = actions.length > 0
    ? `\n\n🔔 REQUIRED ACTIONS:\n${actions.map(a => `- ${a}`).join('\n')}` 
    : '';
  
  // Format stats in a consistent way
  const statsSection = stats 
    ? `\n\n📊 STATS:\n${Object.entries(stats).map(([k, v]) => `- ${k}: ${v}`).join('\n')}` 
    : '';
  
  return {
    content: [
      {
        type: "text" as const,
        text: `${emoji} ${title.toUpperCase()}\n\n${details}${statsSection}${warningSection}${actionSection}`
      }
    ]
  };
}

// Tool schema definitions
export const schemas = {
  session: {
    initialize: {
      taskType: z
        .enum(["code-editing", "planning", "research", "exploration"])
        .describe(
          "The type of task you (the assistant) are performing - YOU MUST specify correctly"
        ),
      contextDescription: z
        .string()
        .optional()
        .describe(
          "Brief description of what you will be doing - BE SPECIFIC and DETAILED"
        ),
      applicationId: z
        .string()
        .optional()
        .describe(
          "The ID of the application you are working on"
        ),
      featureId: z
        .string()
        .optional()
        .describe(
          "The ID of the feature you are working on"
        ),
      taskId: z
        .string()
        .optional()
        .describe(
          "The ID of the specific task you are working on"
        ),
    } as ZodRawShape,
    checkpoint: {
      sessionId: z.string().describe("Your current session ID - REQUIRED to maintain continuity"),
      progress: z.string().describe("YOUR description of progress made so far - BE SPECIFIC about what YOU have accomplished"),
      changesDescription: z.string().describe("YOUR summary of changes YOU have made - DETAIL the files modified and how"),
      currentThinking: z.string().describe("YOUR current reasoning and plan - EXPLAIN your thought process clearly"),
      nextSteps: z.string().optional().describe("YOUR planned next actions - OUTLINE what you intend to do next"),
    } as ZodRawShape,
    end: {
      sessionId: z.string().describe("Your current session ID - REQUIRED to properly close the session"),
      summary: z.string().describe("Summary of what was accomplished in this session")
    } as ZodRawShape
  },
  tracking: {
    recordFileChange: {
      sessionId: z.string().describe("Your current session ID - YOU MUST include this to maintain continuity"),
      filePath: z.string().describe("Path of the file YOU just created, modified or deleted - REQUIRED after ANY file operation"),
      changeType: z
        .enum(["created", "modified", "deleted"])
        .describe("Type of change YOU just performed - MUST be recorded for system integrity"),
    } as ZodRawShape,
    createSnapshot: {
      sessionId: z.string().describe("Your current session ID - REQUIRED to link the snapshot"),
      filePath: z.string().describe("Path of the file to snapshot"),
      content: z.string().describe("The current content of the file"),
    } as ZodRawShape,
    logDecision: {
      sessionId: z.string().describe("Your current session ID - REQUIRED to link the decision"),
      description: z.string().describe("Brief description of the decision made"),
      reasoning: z.string().describe("Detailed reasoning behind the decision"),
      alternatives: z.string().optional().describe("Alternative approaches that were considered"),
    } as ZodRawShape,
    createProgressCheckpoint: {
      sessionId: z.string().optional().describe("Your current session ID - include this to maintain continuity"),
      progress: z.string().describe("YOUR description of progress made so far - BE SPECIFIC about what YOU have accomplished"),
      changesDescription: z.string().describe("YOUR summary of changes YOU have made - DETAIL the files modified and how"),
      currentThinking: z.string().describe("YOUR current reasoning and plan - EXPLAIN your thought process clearly"),
      nextSteps: z.string().optional().describe("YOUR planned next actions - OUTLINE what you intend to do next")
    } as ZodRawShape
  },
  validation: {
    verifyScopeCompliance: {
      sessionId: z.string().describe("Your current session ID - REQUIRED for verification"),
      filePath: z.string().describe("Path of the file you want to modify"),
      operation: z.enum(["create", "modify", "delete"]).describe("The operation you want to perform"),
      reason: z.string().describe("Why this operation is necessary for your assigned task"),
    } as ZodRawShape,
    checkTimeboxing: {
      sessionId: z.string().describe("Your current session ID - REQUIRED for verification"),
    } as ZodRawShape
  },
  knowledge: {
    reviewSuccessfulStrategies: {
      sessionId: z.string().describe("Your current session ID - REQUIRED"),
      taskType: z.enum(["code-editing", "planning", "research", "exploration"])
        .describe("Type of task - MUST match initialization"),
      featureId: z.string().optional().describe("Feature ID if available"),
    } as ZodRawShape,
    recordFeedback: {
      sessionId: z.string().describe("Your current session ID - REQUIRED"),
      decisionId: z.string().optional().describe("Decision this feedback relates to"),
      feedbackType: z.enum(["positive", "negative", "neutral"]).describe("Type of feedback"),
      description: z.string().describe("Description of what worked or didn't work"),
      reusabilityScore: z.number().min(1).max(10).optional().describe("How reusable is this approach (1-10)"),
      applicableTaskTypes: z.array(z.string()).describe("Task types this feedback applies to"),
      tags: z.array(z.string()).optional().describe("Tags for categorizing this feedback"),
    } as ZodRawShape
  },
  application: {
    getApplications: {
      random_string: z.string().optional().describe("Dummy parameter for no-parameter tools")
    } as ZodRawShape,
    getFeatures: {
      applicationId: z.string().describe("The application ID to get features for")
    } as ZodRawShape,
    getTasks: {
      featureId: z.string().describe("The feature ID to get tasks for")
    } as ZodRawShape, 
    getSessionHistory: {
      taskId: z.string().describe("The task ID to retrieve session history for")
    } as ZodRawShape,
    createApplication: {
      name: z.string().describe("Name of the application"),
      description: z.string().optional().describe("Description of the application"),
      repositoryUrl: z.string().optional().describe("URL to the application's repository")
    } as ZodRawShape,
    createFeature: {
      applicationId: z.string().describe("ID of the parent application"),
      name: z.string().describe("Name of the feature"),
      description: z.string().optional().describe("Description of the feature"),
      status: z.enum(["planned", "in_progress", "completed", "abandoned"])
        .default("planned")
        .describe("Current status of the feature"),
      priority: z.number().default(1).describe("Priority of the feature (higher number = higher priority)")
    } as ZodRawShape,
    createTask: {
      featureId: z.string().describe("ID of the parent feature"),
      name: z.string().describe("Name of the task"),
      description: z.string().optional().describe("Description of the task"),
      acceptanceCriteria: z.string().optional().describe("Acceptance criteria for the task"),
      status: z.enum(["backlog", "ready", "in_progress", "review", "completed"])
        .default("backlog")
        .describe("Current status of the task"),
      priority: z.number().default(1).describe("Priority of the task (higher number = higher priority)")
    } as ZodRawShape,
    updateFeatureStatus: {
      featureId: z.string().describe("ID of the feature to update"),
      status: z.enum(["planned", "in_progress", "completed", "abandoned"])
        .describe("New status for the feature")
    } as ZodRawShape,
    updateTaskStatus: {
      taskId: z.string().describe("ID of the task to update"),
      status: z.enum(["backlog", "ready", "in_progress", "review", "completed"])
        .describe("New status for the task")
    } as ZodRawShape
  }
};
</file>

<file path="utils/validation.ts">
import supabase from "../lib/supabase-client.js";

// Check if session exists and is active
export async function validateSession(sessionId: string) {
  if (!sessionId) {
    return {
      valid: false,
      error: "No session ID provided"
    };
  }
  
  const { data, error } = await supabase
    .from('sessions')
    .select('id, status')
    .eq('id', sessionId)
    .single();
    
  if (error || !data) {
    return {
      valid: false,
      error: "Session not found"
    };
  }
  
  if (data.status !== 'active') {
    return {
      valid: false,
      error: `Session is ${data.status}, not active`
    };
  }
  
  return {
    valid: true,
    data
  };
}

// Check if checkpoint is needed
export async function checkpointNeeded(sessionId: string) {
  const { data } = await supabase
    .from('sessions')
    .select('last_checkpoint_at, start_time')
    .eq('id', sessionId)
    .single();
    
  if (!data) return true;
  
  const lastCheckpoint = data.last_checkpoint_at 
    ? new Date(data.last_checkpoint_at) 
    : new Date(data.start_time);
    
  const minutesSinceLastCheckpoint = (Date.now() - lastCheckpoint.getTime()) / 60000;
  
  return minutesSinceLastCheckpoint >= 3;
}

// Verify task scope compliance
export async function verifyScopeCompliance(sessionId: string, filePath: string, operation: string) {
  // This would contain logic to check if the file operation is within scope
  // For example, checking if the file is part of the assigned task
  
  // Basic implementation example:
  const { data: session } = await supabase
    .from('sessions')
    .select('task_id, application_id, feature_id')
    .eq('id', sessionId)
    .single();
    
  if (!session) return { compliant: false, reason: "Session not found" };
  
  // Here you would implement logic to determine if the file path
  // is relevant to the task/feature/application in the session
  
  // For now, we'll return a simple mock result
  return { compliant: true };
}
</file>

</files>
